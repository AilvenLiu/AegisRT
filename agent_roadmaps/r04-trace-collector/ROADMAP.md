# ROADMAP -- r04-trace-collector

> Long-form execution manual. Written for an AI agent with no prior context.

---

## 1. Background and Motivation

TraceCollector is the observability backbone of AegisRT. Every component injects events
into it. Without it:
- Scheduling decisions cannot be reconstructed, debugged, or audited.
- The "observability as a contract" principle cannot be fulfilled.
- The MVP validation criteria (100% decisions reconstructible) cannot be met.

TraceCollector must be thread-safe and non-blocking for producers to avoid impacting
inference latency. It must be pure C++ with no CUDA dependency so it can be used in
unit tests without a GPU.

---

## 2. Overall Objective

By the end of this roadmap, ALL of the following MUST be true:

- TraceCollector records events in a thread-safe ring buffer.
- Ring buffer drops oldest events on overflow (never blocks producers).
- export_json() produces valid JSON parseable by Python json.loads().
- Timestamp uses steady_clock with nanosecond resolution.
- Duration uses integer nanoseconds (no floating-point).
- Thread-safety verified under TSan with 8 concurrent threads.
- reconstruct_decision_chain() returns events in timestamp order.
- No CUDA dependency in any TraceCollector header or source file.

---

## 3. Explicit Non-Goals

- No AuditTrail (r18).
- No MetricsAggregator (r18).
- No Perfetto/CSV export (r19).
- No CUDA dependency.
- No lock-free implementation (mutex is sufficient for MVP).

---

## 4. High-Level Strategy

### Ring Buffer Design

Use a fixed-size circular buffer protected by a std::mutex. The drop-oldest overflow
policy ensures producers are never blocked. This is the correct trade-off for a
real-time system: losing old trace data is acceptable; blocking inference is not.

Buffer size defaults to 10000 events. This is sufficient for several seconds of
multi-model execution at typical event rates.

### Timestamp and Duration Design

Timestamp wraps std::chrono::steady_clock::time_point for monotonicity.
Duration uses int64_t nanoseconds to avoid floating-point precision loss.
This is critical for accurate timing comparisons in the scheduler.

### JSON Export Design

JSON schema:
{
  "events": [
    {
      "event_id": "uuid-string",
      "event_type": "scheduling_decision",
      "component": "Scheduler",
      "timestamp_ns": 1234567890,
      "duration_ns": 45000,
      "model_id": "model_a",
      "request_id": "req-uuid",
      "rationale": "Selected model_a: earliest deadline 14:23:45.200",
      "severity": "Info",
      "attributes": {"wcrt_ns": "72000000", "utilisation": "0.85"}
    }
  ]
}

---

## 5. Sub-Phase A: Core Types

### Objective

Establish Timestamp, Duration, and TraceEvent types before implementing the collector.
These types are used throughout the entire codebase.

### Task Execution Guidance

task-r04-a-0 (Timestamp):
- struct Timestamp { std::chrono::steady_clock::time_point value; }
- static Timestamp now() { return Timestamp{std::chrono::steady_clock::now()}; }
- operator-(const Timestamp& other) const -> Duration
- operator<, operator>, operator<=, operator>=, operator==

task-r04-a-1 (Duration):
- struct Duration { int64_t nanos; }
- static Duration from_nanos(int64_t n) { return Duration{n}; }
- static Duration from_micros(int64_t us) { return Duration{us * 1000}; }
- static Duration from_millis(int64_t ms) { return Duration{ms * 1000000}; }
- static Duration from_seconds(int64_t s) { return Duration{s * 1000000000LL}; }
- int64_t to_nanos() const, to_micros() const, to_millis() const

task-r04-a-2 (Duration arithmetic):
- operator+(Duration), operator-(Duration), operator*(int64_t), operator/(int64_t)
- operator<, operator>, operator<=, operator>=, operator==, operator!=

task-r04-a-3 (TraceEvent):
struct TraceEvent {
    std::string event_id;       // UUID, generated by TraceCollector
    std::string event_type;     // e.g. "scheduling_decision", "admission_result"
    std::string component;      // e.g. "Scheduler", "AdmissionController"
    Timestamp timestamp;
    Duration duration;          // 0 for instantaneous events
    std::string model_id;       // empty if not model-specific
    std::string request_id;     // links related events in a decision chain
    std::string rationale;      // human-readable explanation
    Severity severity;          // Info, Warning, Error, Critical
    std::map<std::string, std::string> attributes;  // key-value pairs
};

task-r04-a-4 (TraceEventBuilder):
- Fluent builder: TraceEventBuilder().with_type("x").with_component("y").build()
- build() validates: event_type and component must be non-empty
- build() auto-generates event_id (UUID) and sets timestamp = Timestamp::now()

task-r04-a-5 (Unit tests):
- Timestamp::now() returns increasing values
- Duration arithmetic is exact (no floating-point)
- TraceEventBuilder validates required fields

### Exit Criteria for Sub-Phase A

- Timestamp, Duration, TraceEvent compile with zero warnings.
- Unit tests pass.
- No CUDA dependency in any header.

---

## 6. Sub-Phase B: TraceCollector Ring Buffer and Thread Safety

### Objective

Implement the thread-safe ring buffer with drop-oldest overflow policy.

### Task Execution Guidance

task-r04-b-0 (Constructor):
- explicit TraceCollector(size_t buffer_size = 10000)
- Validates buffer_size > 0
- Allocates std::vector<TraceEvent> of size buffer_size
- Initialises head_ = 0, tail_ = 0, count_ = 0

task-r04-b-1 (record):
- void record(TraceEvent event)
- Acquires mutex_
- If count_ == buffer_size: drop oldest (advance tail_, decrement count_)
- Insert event at head_, advance head_, increment count_
- Releases mutex_

task-r04-b-2 (record_now):
- void record_now(std::string_view event_type, std::string_view component, std::string_view rationale = "")
- Creates TraceEvent with timestamp = Timestamp::now()
- Calls record()

task-r04-b-3 (size and clear):
- size_t size() const: acquires mutex, returns count_
- void clear(): acquires mutex, resets head_/tail_/count_

task-r04-b-4 (Thread-safety test):
- 8 threads each record 1000 events concurrently
- Run under ThreadSanitizer: zero data races
- After all threads complete: size() <= buffer_size

task-r04-b-5 (Overflow test):
- Fill buffer with buffer_size + 100 events
- Verify size() == buffer_size
- Verify oldest events were dropped (check event_ids)

### Exit Criteria for Sub-Phase B

- record() is thread-safe under TSan.
- Overflow drops oldest events correctly.
- Unit tests pass.

---

## 7. Sub-Phase C: Query API and JSON Export

### Objective

Implement the query API and JSON export that enable offline analysis.

### Task Execution Guidance

task-r04-c-0 (query with filters):
struct TraceQuery {
    std::optional<Timestamp> start;
    std::optional<Timestamp> end;
    std::optional<std::string> event_type;
    std::optional<std::string> model_id;
    std::optional<std::string> component;
    std::optional<Severity> min_severity;
};
- std::vector<TraceEvent> query(const TraceQuery& q) const
- Acquires mutex, copies matching events, releases mutex
- Returns events sorted by timestamp

task-r04-c-1 (convenience query methods):
- query_by_component(std::string_view component) -> vector<TraceEvent>
- query_by_severity(Severity min_severity) -> vector<TraceEvent>
- query_by_model(std::string_view model_id) -> vector<TraceEvent>

task-r04-c-2 (export_json):
- void export_json(const std::string& path) const
- Opens file, writes JSON array of all events
- Timestamps as integer nanoseconds since steady_clock epoch
- Durations as integer nanoseconds

task-r04-c-3 (JSON timestamp format):
- timestamp_ns: int64_t nanoseconds since steady_clock epoch
- duration_ns: int64_t nanoseconds
- Do NOT use floating-point for timestamps or durations

task-r04-c-4 (reconstruct_decision_chain):
- std::vector<TraceEvent> reconstruct_decision_chain(const std::string& request_id) const
- Returns all events with matching request_id, sorted by timestamp
- Foundation for AuditTrail in r18

task-r04-c-5 (Unit tests):
- record/query round-trip: recorded events are returned by query
- Filter accuracy: only matching events returned
- JSON export: Python json.loads() parses output without error
- reconstruct_decision_chain: returns events in timestamp order

task-r04-c-6 (Validation):
- clang-tidy on all new files: zero warnings
- No CUDA dependency in any header or source file
- All public APIs have Doxygen comments

### Exit Criteria for Sub-Phase C

- query() returns correct filtered results.
- export_json() produces valid JSON.
- reconstruct_decision_chain() works correctly.
- No CUDA dependency.

---

## 8. Completion Definition

This roadmap is complete when:
- All tasks in all three sub-phases are marked completed in roadmap.yml.
- All exit criteria above are verified.
- TSan reports zero data races.
- A session handoff file exists in sessions/.
- agent_roadmaps/README.md updated to reflect r04 completed and r05 active.
